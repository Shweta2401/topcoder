// BEGIN CUT HERE
/*
// PROBLEM STATEMENT
// John and Brus are studying string theory at the university.  According to Brus, a string is called lucky if no two consecutive characters are equal.  John is analyzing a string s, and he wants to know how many distinct lucky strings can be generated by reordering the letters in s.  If s is a lucky string in its original ordering, it should also be considered in the count.

DEFINITION
Class:TheLuckyString
Method:count
Parameters:string
Returns:int
Method signature:int count(string s)


CONSTRAINTS
-s will contain between 1 and 10 characters, inclusive.
-Each character of s will be a lowercase letter ('a' - 'z').


EXAMPLES

0)
"ab"

Returns: 2

Two lucky strings - "ab" and "ba".

1)
"aaab"

Returns: 0

It's impossible to construct a lucky string.

2)
"aabbbaa"

Returns: 1

"abababa" is the only lucky string that can be generated.

3)
"abcdefghij"

Returns: 3628800

*/
// END CUT HERE

#line 51 "TheLuckyString.cpp"
#include <string>
#include <vector>
#include <set>
#include <map>
#include <list>
#include <queue>
#include <algorithm>
// BEGIN CUT HERE
#include <iostream>
#include "cout.h"
#include <time.h>
// END CUT HERE
#include <sstream>
#include <cmath>
using namespace std;

#define sz(a)  int((a).size())
#define pb  push_back
#define all(c)  (c).begin(),(c).end()
#define tr(c,i)  for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)

class TheLuckyString {
public:
  int count(string s) {
	int n = s.size();
	int M = 1 << n;
	vector<vector<set<vector<int> > > > t(n); // [st][ma][..]
	for (int i=0;i<n;i++) {
	  t[i].resize(M);
	  //vector<int> v(0);
	  //for (int m=0;m<M;m++) t[i][m] = v;
	}
	for (int la=0;la<n;la++) {
	  vector<int> v(1); v[0] = s[la];
	  t[0][1<<la].insert( v );
	}
	for (int st=0;st<n-1;st++) {
	  for (int m=0;m<M;m++) {
		if (t[st][m].size() == 0) continue;
		tr(t[st][m],it) {
		  vector<int> v_(all(*it));
		  int vs = v_.size();
		  v_.pb(0);
		  for (int nx=0;nx<n;nx++) {
			if (m & (1 << nx)) continue;
			v_[vs] = s[nx];
			t[st+1][m|(1<<nx)].insert( v_ );
		  }
		}
	  }
	}

	return t[n-1][M-1].size();
  }
// BEGIN CUT HERE
  clock_t start;
  void timer_clear()
  {
	start = clock();
  }
  char *timer()
  {
	clock_t end = clock();
	double interval = (double)(end - start)/CLOCKS_PER_SEC;
	
	char *ret = NULL;
	asprintf(&ret, " (%g msec)", interval*1000);
	return ret;
  }
// END CUT HERE
	
// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arg0 = "ab"; int Arg1 = 2; verify_case(0, Arg1, count(Arg0)); }
	void test_case_1() { string Arg0 = "aaab"; int Arg1 = 0; verify_case(1, Arg1, count(Arg0)); }
	void test_case_2() { string Arg0 = "aabbbaa"; int Arg1 = 1; verify_case(2, Arg1, count(Arg0)); }
	void test_case_3() { string Arg0 = "abcdefghij"; int Arg1 = 3628800; verify_case(3, Arg1, count(Arg0)); }

// END CUT HERE

};

// BEGIN CUT HERE
int main(int argc, char *argv[]) {
	TheLuckyString ___test;
	___test.run_test( argc>=2 ? atoi(argv[1]):-1 );
}
// END CUT HERE
