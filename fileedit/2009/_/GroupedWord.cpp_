// BEGIN CUT HERE
/*
// PROBLEM STATEMENT
// A word is grouped if, for each letter in the word, all occurrences of that letter form exactly one consecutive sequence.  In other words, no two equal letters are separated by one or more letters that are different.  For example, the words "ccazzzzbb" and "code" are grouped, while "aabbbccb" and "topcoder" are not.

A grouped word was divided into several parts.  You are given all the parts in random order as a vector <string>.  Reconstruct the original word and return it.  If there is more than one possible answer, return "MANY" instead.  If no grouped word could have resulted in the given parts, return "IMPOSSIBLE" instead (all quotes for clarity).


DEFINITION
Class:GroupedWord
Method:restore
Parameters:vector <string>
Returns:string
Method signature:string restore(vector <string> parts)


CONSTRAINTS
-parts will contain between 1 and 50 elements, inclusive.
-Each element of parts will contain between 1 and 20 characters, inclusive.
-Each element of parts will contain only lowercase letters ('a' - 'z').


EXAMPLES

0)
{"aaa", "a", "aa"}

Returns: "aaaaaa"

These parts could only have come from the word "aaaaaa", which is a grouped word.

1)
{"ab", "bba"}

Returns: "IMPOSSIBLE"

The only possible original words are "abbba" and "bbaab", and neither of them are grouped words.

2)
{"te", "st"}

Returns: "stte"



3)
{"te", "s", "t"}

Returns: "MANY"

The initial word could be either "stte" or "ttes".

4)
{"orr", "rd", "woo", "www"}

Returns: "wwwwooorrrd"



5)
{"abcb"}

Returns: "IMPOSSIBLE"

*/
// END CUT HERE

#line 69 "GroupedWord.cpp"
#include <string>
#include <vector>
#include <set>
#include <map>
#include <list>
#include <queue>
#include <algorithm>
// BEGIN CUT HERE
#include <iostream>
#include "cout.h"
// END CUT HERE
#include <sstream>
#include <cmath>
using namespace std;

#define sz(a)  int((a).size())
#define pb  push_back
#define all(c)  (c).begin(),(c).end()
#define tr(c,i)  for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)
#define rep(var,n)  for(int var=0;var<(n);var++)
#define found(s,e)  ((s).find(e)!=(s).end())
#define remove_(c,val) (c).erase(remove((c).begin(),(c).end(),(val)),(c).end())

class GroupedWord {
  vector<string> ps;
  vector<long long> ums;
  int n;
  long long m;
  vector<int> sub(vector<int> h, set<int> hs, long long um, int c){
    int hi=sz(h)-1;
    h.pb(-1);
    int la=ps[hi][ps[hi].length()-1]-'a';
    vector<int> s_;
    rep(i,n){
      if(i==c)continue; if(found(hs,i))continue;
      int b=ps[i][0]-'a';
      if(b==la || ((um & (1LL<<b))==0) ){
        h[hi+1]=i;
        hs.insert(i);
        vector<int> s = sub(h, hs, um|ums[i], i);
        if(sz(s_)==0) s_=s;
        else if(sz(s)>0) return "MANY";
        hs.erase(i);
      }
    }
  }
    
 public:
  string restore(vector<string> parts) {
    ps=parts;
    n=sz(parts);//1-50
    ums.resize(n);tr(ums,it) *it=0;
    rep(i,n){
      string p=parts[i];
      rep(j,p.length()){
        long long c=1LL<<(p[j]-'a');
        ums[i] |= c;
      }
    }
    m=(1LL<<n)-1;
    vector<int> res;
    rep(i,n){
      vector<int> h(1,i);
      set<int> hs; hs.insert(i);
      vector<int> s = sub(h,hs,ums[i],i);
      if(sz(s)==0) continue;
      if(sz(res)>=0) return "IMPOSSIBLE";
    }
    stringstream ss;
    tr(res,it) ss << *it;
    return ss.str();
  }
};

// BEGIN CUT HERE
#include <time.h>
clock_t start_time;
void timer_clear() { start_time = clock(); }
string timer() { clock_t end_time = clock(); double interval = (double)(end_time - start_time)/CLOCKS_PER_SEC; ostringstream os; os << " (" << interval*1000 << " msec)"; return os.str(); }

template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
int verify_case(const string &Expected, const string &Received) { if (Expected == Received) cerr << "PASSED" << timer() << endl; else { cerr << "FAILED" << timer() << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } return 0;}

template<int N> struct Case_ {};
char Test_(...);
int Test_(Case_<0>) {
	timer_clear();
	string parts_[] = {"aaa", "a", "aa"};
	  vector <string> parts(parts_, parts_+sizeof(parts_)/sizeof(*parts_)); 
	string RetVal = "aaaaaa"; 
	return verify_case(RetVal, GroupedWord().restore(parts)); }
int Test_(Case_<1>) {
	timer_clear();
	string parts_[] = {"ab", "bba"};
	  vector <string> parts(parts_, parts_+sizeof(parts_)/sizeof(*parts_)); 
	string RetVal = "IMPOSSIBLE"; 
	return verify_case(RetVal, GroupedWord().restore(parts)); }
int Test_(Case_<2>) {
	timer_clear();
	string parts_[] = {"te", "st"};
	  vector <string> parts(parts_, parts_+sizeof(parts_)/sizeof(*parts_)); 
	string RetVal = "stte"; 
	return verify_case(RetVal, GroupedWord().restore(parts)); }
int Test_(Case_<3>) {
	timer_clear();
	string parts_[] = {"te", "s", "t"};
	  vector <string> parts(parts_, parts_+sizeof(parts_)/sizeof(*parts_)); 
	string RetVal = "MANY"; 
	return verify_case(RetVal, GroupedWord().restore(parts)); }
int Test_(Case_<4>) {
	timer_clear();
	string parts_[] = {"orr", "rd", "woo", "www"};
	  vector <string> parts(parts_, parts_+sizeof(parts_)/sizeof(*parts_)); 
	string RetVal = "wwwwooorrrd"; 
	return verify_case(RetVal, GroupedWord().restore(parts)); }
int Test_(Case_<5>) {
	timer_clear();
	string parts_[] = {"abcb"};
	  vector <string> parts(parts_, parts_+sizeof(parts_)/sizeof(*parts_)); 
	string RetVal = "IMPOSSIBLE"; 
	return verify_case(RetVal, GroupedWord().restore(parts)); }
int Test_(Case_<6>) {
	timer_clear();
	string parts_[] = {"a", "b"};
	  vector <string> parts(parts_, parts_+sizeof(parts_)/sizeof(*parts_)); 
	string RetVal = "IMPOSSIBLE"; 
	return verify_case(RetVal, GroupedWord().restore(parts)); }

template<int N> void Run_() { cerr << "Test Case #" << N << "..." << flush; Test_(Case_<N>()); Run_<sizeof(Test_(Case_<N+1>()))==1 ? -1 : N+1>(); }
template<>      void Run_<-1>() {}
int main() { Run_<0>(); }
// END CUT HERE

